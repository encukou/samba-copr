Index: source/client/client.c
===================================================================
--- source/client/client.c	(revision 21990)
+++ source/client/client.c	(working copy)
@@ -3847,6 +3847,8 @@
 	char *p;
 	int rc = 0;
 	fstring new_workgroup;
+	BOOL tar_opt = False;
+	BOOL service_opt = False;
 	struct poptOption long_options[] = {
 		POPT_AUTOHELP
 
@@ -3893,13 +3895,43 @@
 		x_setbuf( dbf, NULL );
 	}
 
-	pc = poptGetContext("smbclient", argc, (const char **) argv, long_options, 
-				POPT_CONTEXT_KEEP_FIRST);
+	/* skip argv(0) */
+	pc = poptGetContext("smbclient", argc, (const char **) argv, long_options, 0);
 	poptSetOtherOptionHelp(pc, "service <password>");
 
 	in_client = True;   /* Make sure that we tell lp_load we are */
 
 	while ((opt = poptGetNextOpt(pc)) != -1) {
+
+		/* if the tar option has been called previouslt, now we need to eat out the leftovers */
+		/* I see no other way to keep things sane --SSS */
+		if (tar_opt == True) {
+			while (poptPeekArg(pc)) {
+				poptGetArg(pc);
+			}
+			tar_opt = False;
+		}
+
+		/* if the service has not yet been specified lets see if it is available in the popt stack */
+		if (!service_opt && poptPeekArg(pc)) {
+			pstrcpy(service, poptGetArg(pc));
+			/* Convert any '/' characters in the service name to '\' characters */
+			string_replace(service, '/','\\');
+
+			if (count_chars(service,'\\') < 3) {
+				d_printf("\n%s: Not enough '\\' characters in service\n",service);
+				poptPrintUsage(pc, stderr, 0);
+				exit(1);
+			}
+			service_opt = True;
+		}
+
+		/* if the service has already been retrieved then check if we have also a password */
+		if (service_opt && (!cmdline_auth_info.got_pass) && poptPeekArg(pc)) {
+			pstrcpy(cmdline_auth_info.password, poptGetArg(pc));
+			cmdline_auth_info.got_pass = True;
+		}
+	
 		switch (opt) {
 		case 'M':
 			/* Messages are sent to NetBIOS name type 0x3
@@ -3954,13 +3986,9 @@
 					poptPrintUsage(pc, stderr, 0);
 					exit(1);
 				}
-				/* Now we must eat (optnum - i) options - they have
-				 * been processed by tar_parseargs().
-				 */
-				optnum -= i;
-				for (i = 0; i < optnum; i++)
-					poptGetOptArg(pc);
 			}
+			/* this must be the last option, mark we have parsed it so that we know we have */
+			tar_opt = True;
 			break;
 		case 'D':
 			pstrcpy(base_directory,poptGetOptArg(pc));
@@ -3971,8 +3999,34 @@
 		}
 	}
 
-	poptGetArg(pc);
+	/* We may still have some leftovers after the last popt option has been called */
+	if (tar_opt == True) {
+		while (poptPeekArg(pc)) {
+			poptGetArg(pc);
+		}
+		tar_opt = False;
+	}
 
+	/* if the service has not yet been specified lets see if it is available in the popt stack */
+	if (!service_opt && poptPeekArg(pc)) {
+		pstrcpy(service, poptGetArg(pc));
+		/* Convert any '/' characters in the service name to '\' characters */
+		string_replace(service, '/','\\');
+
+		if (count_chars(service,'\\') < 3) {
+			d_printf("\n%s: Not enough '\\' characters in service\n",service);
+			poptPrintUsage(pc, stderr, 0);
+			exit(1);
+		}
+		service_opt = True;
+	}
+
+	/* if the service has already been retrieved then check if we have also a password */
+	if (service_opt && (!cmdline_auth_info.got_pass) && poptPeekArg(pc)) {
+		pstrcpy(cmdline_auth_info.password, poptGetArg(pc));
+		cmdline_auth_info.got_pass = True;
+	}
+	
 	/* check for the -P option */
 
 	if ( port != 0 )
@@ -4011,23 +4065,6 @@
 	else
 		pstrcpy( calling_name, global_myname() );
 
-	if(poptPeekArg(pc)) {
-		pstrcpy(service,poptGetArg(pc));  
-		/* Convert any '/' characters in the service name to '\' characters */
-		string_replace(service, '/','\\');
-
-		if (count_chars(service,'\\') < 3) {
-			d_printf("\n%s: Not enough '\\' characters in service\n",service);
-			poptPrintUsage(pc, stderr, 0);
-			exit(1);
-		}
-	}
-
-	if (poptPeekArg(pc) && !cmdline_auth_info.got_pass) { 
-		cmdline_auth_info.got_pass = True;
-		pstrcpy(cmdline_auth_info.password,poptGetArg(pc));  
-	}
-
 	init_names();
 
 	if(new_name_resolve_order)
